Only in after/: bears.json
Only in after/: classpath.info
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/support/visitor/ClassTypingContext.java after/src/main/java/spoon/support/visitor/ClassTypingContext.java
44a45
> import spoon.support.SpoonClassNotFoundException;
191a193,197
> 		 * remove last resolved class from the list of visited,
> 		 * because it would avoid visiting it's super hierarchy
> 		 */
> 		getVisitedSet().remove(lastResolvedSuperclass.getQualifiedName());
> 		/*
207c213,235
< 				List<CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(typeRef.getActualTypeArguments());
---
> 				List<CtTypeReference<?>> actualTypeArguments = typeRef.getActualTypeArguments();
> 				if (actualTypeArguments.isEmpty()) {
> 					//may be they are not set - check whether type declares some generic parameters
> 					List<CtTypeParameter> typeParams;
> 					try {
> 						CtType<?> type = typeRef.getTypeDeclaration();
> 						typeParams = type.getFormalCtTypeParameters();
> 					} catch (final SpoonClassNotFoundException e) {
> 						if (typeRef.getFactory().getEnvironment().getNoClasspath()) {
> 							typeParams = Collections.emptyList();
> 						} else {
> 							throw e;
> 						}
> 					}
> 					if (typeParams.size() > 0) {
> 						//yes, there are generic type parameters. Reference should use actualTypeArguments computed from their bounds
> 						actualTypeArguments = new ArrayList<>(typeParams.size());
> 						for (CtTypeParameter typeParam : typeParams) {
> 							actualTypeArguments.add(typeParam.getTypeErasure());
> 						}
> 					}
> 				}
> 				List<CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(actualTypeArguments);
218a247,252
> 		if (listener.foundArguments == null) {
> 			/*
> 			 * superclass was not found. We have scanned whole hierarchy
> 			 */
> 			lastResolvedSuperclass = null;
> 		}
430,434d463
< 			ScanningMode mode = super.enter(typeRef);
< 			if (mode == ScanningMode.SKIP_ALL) {
< 				//this interface was already visited. Do not visit it again
< 				return mode;
< 			}
435a465,468
> 				/*
> 				 * test foundArguments and skip all before call of super.enter,
> 				 * which would add that not visited type into visitedSet
> 				 */
446a480,484
> 			}
> 			ScanningMode mode = super.enter(typeRef);
> 			if (mode == ScanningMode.SKIP_ALL) {
> 				//this interface was already visited. Do not visit it again
> 				return mode;
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/reflect/declaration/CtTypeInformationTest.java after/src/test/java/spoon/reflect/declaration/CtTypeInformationTest.java
5a6,10
> import java.lang.reflect.Field;
> import java.util.AbstractCollection;
> import java.util.AbstractList;
> import java.util.ArrayList;
> import java.util.RandomAccess;
17a23
> import spoon.support.visitor.ClassTypingContext;
24a31,125
> 	}
> 
> 	@Test
> 	public void testClassTypingContextContinueScanning() throws Exception {
> 
> 		final CtType<?> subClass = this.factory.Type().get(Subclass.class);
> 		final CtTypeReference<?> subinterface = this.factory.Type().createReference(Subinterface.class);
> 		final CtTypeReference<?> testInterface = this.factory.Type().createReference(TestInterface.class);
> 		final CtTypeReference<?> extendObject = this.factory.Type().createReference(ExtendsObject.class);
> 		final CtTypeReference<?> arrayList = this.factory.Type().createReference(ArrayList.class);
> 		final CtTypeReference<?> abstractList = this.factory.Type().createReference(AbstractList.class);
> 		final CtTypeReference<?> abstractCollection = this.factory.Type().createReference(AbstractCollection.class);
> 		final CtTypeReference<?> object = this.factory.Type().createReference(Object.class);
> 
> 		{
> 			final ClassTypingContext ctc = (ClassTypingContext) this.factory.createTypeAdapter(subClass);
> 			//contract: at the beginning, the last resolved class is a subClass
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			//contract: this.isSubttypeOf(this) == true
> 			Assert.assertTrue(ctc.isSubtypeOf(subClass.getReference()));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 
> 			Assert.assertTrue(ctc.isSubtypeOf(subinterface));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 
> 			Assert.assertTrue(ctc.isSubtypeOf(testInterface));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 
> 			Assert.assertTrue(ctc.isSubtypeOf(factory.createCtTypeReference(Comparable.class)));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 
> 			Assert.assertTrue(ctc.isSubtypeOf(extendObject));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(extendObject.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			Assert.assertTrue(ctc.isSubtypeOf(arrayList));
> 			//contract: ClassTypingContext#isSubtypeOf returns always the same results 
> 			Assert.assertTrue(ctc.isSubtypeOf(extendObject));
> 			Assert.assertTrue(ctc.isSubtypeOf(subClass.getReference()));
> 			
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(arrayList.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			Assert.assertTrue(ctc.isSubtypeOf(factory.createCtTypeReference(RandomAccess.class)));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(arrayList.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			Assert.assertTrue(ctc.isSubtypeOf(abstractList));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(abstractList.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			Assert.assertTrue(ctc.isSubtypeOf(abstractCollection));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(abstractCollection.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			Assert.assertTrue(ctc.isSubtypeOf(object));
> 			//contract: ClassTypingContext did not scanned whole type hierarchy. It stopped on last class - even on java.lang.Object, which was needed to agree on isSubtypeOf
> 			Assert.assertEquals(object.getQualifiedName(), getLastResolvedSuperclass(ctc).getQualifiedName());
> 			
> 			//contract: ClassTypingContext returns false on a type which is not a sub type of ctc scope.
> 			Assert.assertFalse(ctc.isSubtypeOf(factory.Type().createReference("java.io.InputStream")));
> 			//contract: ClassTypingContext must scans whole type hierarchy if detecting subtypeof on type which is not a supertype
> 			Assert.assertNull(getLastResolvedSuperclass(ctc));
> 			//contract: ClassTypingContext#isSubtypeOf returns always the same results 
> 			Assert.assertTrue(ctc.isSubtypeOf(arrayList));
> 			Assert.assertTrue(ctc.isSubtypeOf(extendObject));
> 			Assert.assertTrue(ctc.isSubtypeOf(subClass.getReference()));
> 		}
> 		
> 		{
> 			//now try directly a type which is not a supertype
> 			final ClassTypingContext ctc2 = (ClassTypingContext) this.factory.createTypeAdapter(subClass);
> 			//contract: at the beginning, the last resolved class is a subClass
> 			Assert.assertEquals(subClass.getQualifiedName(), getLastResolvedSuperclass(ctc2).getQualifiedName());
> 			//contract: ClassTypingContext returns false on a type which is not a sub type of ctc scope.
> 			Assert.assertFalse(ctc2.isSubtypeOf(factory.Type().createReference("java.io.InputStream")));
> 			//contract: ClassTypingContext must scans whole type hierarchy if detecting subtypeof on type which is not a supertype
> 			Assert.assertNull(getLastResolvedSuperclass(ctc2));
> 			
> 			//contract: ClassTypingContext#isSubtypeOf returns always the same results 
> 			Assert.assertTrue(ctc2.isSubtypeOf(arrayList));
> 			Assert.assertTrue(ctc2.isSubtypeOf(extendObject));
> 			Assert.assertTrue(ctc2.isSubtypeOf(subClass.getReference()));
> 		}
> 	}
> 	
> 	private CtTypeInformation getLastResolvedSuperclass(ClassTypingContext ctc) throws Exception {
> 		Field f = ClassTypingContext.class.getDeclaredField("lastResolvedSuperclass");
> 		f.setAccessible(true);
> 		return (CtTypeInformation) f.get(ctc);
