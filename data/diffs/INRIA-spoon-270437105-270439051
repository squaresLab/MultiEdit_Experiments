Only in after/: bears.json
Only in after/: classpath.info
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/support/visitor/ProcessingVisitor.java after/src/main/java/spoon/support/visitor/ProcessingVisitor.java
48,49c48,49
< 				if (((Class<?>) o).isAssignableFrom(e.getClass())) {
< 					return true;
---
> 				if (!((Class<?>) o).isAssignableFrom(e.getClass())) {
> 					return false;
51a52
> 			return true;
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/processing/ProcessingTest.java after/src/test/java/spoon/test/processing/ProcessingTest.java
15a16
> import spoon.reflect.declaration.CtInterface;
16a18
> import spoon.reflect.declaration.CtType;
18a21,23
> import spoon.test.processing.testclasses.CtClassProcessor;
> import spoon.test.processing.testclasses.CtInterfaceProcessor;
> import spoon.test.processing.testclasses.CtTypeProcessor;
181a187,251
> 	}
> 
> 	@Test
> 	public void testProcessorWithGenericType() {
> 		// contract: we can use generic type for another abstract processor
> 
> 		Launcher spoon = new Launcher();
> 		spoon.addInputResource("./src/test/java/spoon/test/imports/testclasses");
> 
> 		CtClassProcessor classProcessor = new CtClassProcessor();
> 		spoon.addProcessor(classProcessor);
> 
> 		spoon.run();
> 
> 		assertFalse(classProcessor.elements.isEmpty());
> 
> 		for (CtType type : classProcessor.elements) {
> 			assertTrue("Type "+type.getSimpleName()+" is not a class", type instanceof CtClass);
> 		}
> 	}
> 
> 	@Test
> 	public void testCallProcessorWithMultipleTypes() {
> 		// contract: when calling a processor capable of treating CtClass and another capable of treating CtType, they are called on the right types
> 
> 		Launcher spoon = new Launcher();
> 		spoon.addInputResource("./src/test/java/spoon/test/imports/testclasses");
> 
> 		CtClassProcessor classProcessor = new CtClassProcessor();
> 		spoon.addProcessor(classProcessor);
> 
> 		CtTypeProcessor typeProcessor = new CtTypeProcessor();
> 		spoon.addProcessor(typeProcessor);
> 
> 		CtInterfaceProcessor interfaceProcessor = new CtInterfaceProcessor();
> 		spoon.addProcessor(interfaceProcessor);
> 
> 		spoon.run();
> 
> 		assertFalse(classProcessor.elements.isEmpty());
> 
> 		for (CtType type : classProcessor.elements) {
> 			assertTrue("Type "+type.getSimpleName()+" is not a class", type instanceof CtClass);
> 		}
> 
> 		assertFalse(classProcessor.elements.isEmpty());
> 
> 		for (CtType type : interfaceProcessor.elements) {
> 			assertTrue("Type "+type.getSimpleName()+" is not an interface", type instanceof CtInterface);
> 		}
> 
> 		assertFalse(typeProcessor.elements.isEmpty());
> 
> 		for (CtType type : typeProcessor.elements) {
> 			if (type instanceof CtClass) {
> 				assertTrue(classProcessor.elements.contains(type));
> 				assertFalse(interfaceProcessor.elements.contains(type));
> 			} else if (type instanceof CtInterface){
> 				assertFalse(classProcessor.elements.contains(type));
> 				assertTrue(interfaceProcessor.elements.contains(type));
> 			} else {
> 				assertFalse(classProcessor.elements.contains(type));
> 				assertFalse(interfaceProcessor.elements.contains(type));
> 			}
> 		}
Only in after/src/test/java/spoon/test/processing: testclasses
