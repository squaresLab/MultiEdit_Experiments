Only in after/: bears.json
Only in after/: classpath.info
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/filter/SuperInheritanceHierarchyFunction.java after/src/main/java/spoon/reflect/visitor/filter/SuperInheritanceHierarchyFunction.java
59a60,100
> 	 * Super inheritance hierarchy scanning listener.
> 	 * Use it instead of {@link CtScannerListener}
> 	 * if you need to know whether visited type reference is class or interface
> 	 */
> 	private static class Listener implements CtScannerListener {
> 
> 		/**
> 		 * Called before the scanner enters an type
> 		 *
> 		 * @param typeRef the type reference to be scanned.
> 		 * @param isClass true if type reference refers to class, false if it is an interface
> 		 * @return a {@link ScanningMode} that drives how the scanner processes this element and its children.
> 		 * For instance, returning {@link ScanningMode#SKIP_ALL} causes that element and all children to be skipped and {@link #exit(CtElement)} are be NOT called for that element.
> 		 */
> 		public ScanningMode enter(CtTypeReference<?> typeRef, boolean isClass) {
> 			return enter((CtElement) typeRef);
> 		}
> 
> 		/**
> 		 * This method is called after the element and all its children have been visited.
> 		 * This method is NOT called if an exception is thrown in {@link #enter(CtElement)} or during the scanning of the element or any of its children element.
> 		 * This method is NOT called for an element for which {@link #enter(CtElement)} returned {@link ScanningMode#SKIP_ALL}.
> 		 *
> 		 * @param typeRef the type reference that has just been scanned.
> 		 * @param isClass true if type reference refers to class, false if it is an interface
> 		 */
> 		public void exit(CtTypeReference<?> typeRef, boolean isClass) {
> 			exit((CtElement) typeRef);
> 		}
> 
> 		@Override
> 		public ScanningMode enter(CtElement element) {
> 			return ScanningMode.NORMAL;
> 		}
> 
> 		@Override
> 		public void exit(CtElement element) {
> 		}
> 	}
> 
> 	/**
90c131
< 	public static class DistinctTypeListener implements CtScannerListener {
---
> 	public static class DistinctTypeListener extends Listener {
167a209,211
> 		CtType<?> type;
> 		//detect whether input is a class or something else (e.g. interface)
> 		boolean isClass;
169c213,214
< 			typeRef = ((CtType<?>) input).getReference();
---
> 			type = (CtType<?>) input;
> 			typeRef = type.getReference();
171a217,230
> 			try {
> 				type = typeRef.getTypeDeclaration();
> 			} catch (SpoonClassNotFoundException e) {
> 				if (typeRef.getFactory().getEnvironment().getNoClasspath() == false) {
> 					throw e;
> 				}
> 				type = null;
> 			}
> 		}
> 		//if the type is unknown, than we expect it is interface, otherwise we would visit java.lang.Object too, even for interfaces
> 		isClass = type == null ? false : (type instanceof CtClass);
> 		if (isClass == false && includingInterfaces == false) {
> 			//the input is interface, but this scanner should visit only interfaces. Finish
> 			return;
173c232
< 		ScanningMode mode = enter(typeRef);
---
> 		ScanningMode mode = enter(typeRef, isClass);
185c244,249
< 			visitSuperClasses(typeRef, outputConsumer, includingInterfaces);
---
> 			if (isClass == false) {
> 				visitSuperInterfaces(typeRef, outputConsumer);
> 			} else {
> 				//call visitSuperClasses only for input of type class. The contract of visitSuperClasses requires that
> 				visitSuperClasses(typeRef, outputConsumer, includingInterfaces);
> 			}
187c251
< 		exit(typeRef);
---
> 		exit(typeRef, isClass);
192a257
> 	 * @param superTypeRef the reference to a class. This method is called only for classes. Never for interface
208,222c273,275
< 			CtType<?> superType;
< 			try {
< 				superType = superTypeRef.getTypeDeclaration();
< 			} catch (SpoonClassNotFoundException e) {
< 				if (failOnClassNotFound) {
< 					throw e;
< 				}
< 				return;
< 			}
< 			if (superType instanceof CtClass) {
< 				// only CtCLasses extend object, so visit Object too
< 				superClassRef = superTypeRef.getFactory().Type().OBJECT;
< 			} else {
< 				return;
< 			}
---
> 			//only CtClasses extend object,
> 			//this method is called only for classes (not for interfaces) so we know we can visit java.lang.Object now too
> 			superClassRef = superTypeRef.getFactory().Type().OBJECT;
224c277
< 		ScanningMode mode = enter(superClassRef);
---
> 		ScanningMode mode = enter(superClassRef, false);
232c285
< 		exit(superClassRef);
---
> 		exit(superClassRef, false);
251c304
< 			ScanningMode mode = enter(ifaceRef);
---
> 			ScanningMode mode = enter(ifaceRef, true);
259c312
< 			exit(ifaceRef);
---
> 			exit(ifaceRef, true);
271,272c324,332
< 	private ScanningMode enter(CtTypeReference<?> type) {
< 		return listener == null ? NORMAL : listener.enter(type);
---
> 	private ScanningMode enter(CtTypeReference<?> type, boolean isClass) {
> 		if (listener == null) {
> 			return NORMAL;
> 		}
> 		if (listener instanceof Listener) {
> 			Listener typeListener = (Listener) listener;
> 			return typeListener.enter(type, isClass);
> 		}
> 		return listener.enter(type);
275c335
< 	private void exit(CtTypeReference<?> type) {
---
> 	private void exit(CtTypeReference<?> type, boolean isClass) {
277c337,341
< 			listener.exit(type);
---
> 			if (listener instanceof Listener) {
> 				((Listener) listener).exit(type, isClass);
> 			} else {
> 				listener.exit(type);
> 			}
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/support/visitor/ClassTypingContext.java after/src/main/java/spoon/support/visitor/ClassTypingContext.java
27d26
< import spoon.reflect.declaration.CtClass;
321,322c320,321
< 		public ScanningMode enter(CtElement element) {
< 			ScanningMode mode = super.enter(element);
---
> 		public ScanningMode enter(CtTypeReference<?> typeRef, boolean isClass) {
> 			ScanningMode mode = super.enter(typeRef);
327,328c326
< 			CtType<?> type = ((CtTypeReference<?>) element).getTypeDeclaration();
< 			if (type instanceof CtClass) {
---
> 			if (isClass) {
339c337
< 				lastResolvedSuperclass = type;
---
> 				lastResolvedSuperclass = typeRef;
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/imports/ImportTest.java after/src/test/java/spoon/test/imports/ImportTest.java
8a9
> import spoon.reflect.CtModel;
882a884,916
> 	}
> 	
> 	@Test
> 	public void testSuperInheritanceHierarchyFunctionNoClasspath() {
> 		final Launcher launcher = new Launcher();
> 		launcher.getEnvironment().setNoClasspath(true);
> 		launcher.addInputResource("src/test/resources/noclasspath/superclass/UnknownSuperClass.java");
> 		launcher.buildModel();
> 		final CtModel model = launcher.getModel();
> 		
> 		CtClass<?> classUSC = launcher.getFactory().Class().get("UnknownSuperClass");
> 		
> 		//contract: super inheritance scanner returns only Types on class path including final Object
> 		List<CtType> types = classUSC.map(new SuperInheritanceHierarchyFunction().includingSelf(true)).list();
> 		assertEquals(2, types.size());
> 		assertEquals("UnknownSuperClass", types.get(0).getQualifiedName());
> 		assertEquals("java.lang.Object", types.get(1).getQualifiedName());
> 
> 		//contract: super inheritance scanner in reference mode returns type references including these which are not on class path and including final Object
> 		List<CtTypeReference> typeRefs = classUSC.map(new SuperInheritanceHierarchyFunction().includingSelf(true).returnTypeReferences(true)).list();
> 		assertEquals(3, typeRefs.size());
> 		assertEquals("UnknownSuperClass", typeRefs.get(0).getQualifiedName());
> 		assertEquals("NotInClasspath", typeRefs.get(1).getQualifiedName());
> 		assertEquals("java.lang.Object", typeRefs.get(2).getQualifiedName());
> 
> 		//contract: super inheritance scanner in reference mode, which starts on class which is not available in model returns no Object, because it does not know if type is class or interface 
> 		typeRefs = classUSC.getSuperclass().map(new SuperInheritanceHierarchyFunction().includingSelf(true).returnTypeReferences(true)).list();
> 		assertEquals(1, typeRefs.size());
> 		assertEquals("NotInClasspath", typeRefs.get(0).getQualifiedName());
> 
> 		//contract: super inheritance scanner in type mode, which starts on class which is not available in model returns nothing 
> 		types = classUSC.getSuperclass().map(new SuperInheritanceHierarchyFunction().includingSelf(true)).list();
> 		assertEquals(0, types.size());
