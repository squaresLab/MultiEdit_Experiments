Only in after/: bears.json
Only in after/: classpath.info
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java after/src/main/java/spoon/reflect/visitor/ImportScannerImpl.java
24a25
> import spoon.reflect.code.CtLiteral;
56a58
> import java.util.StringTokenizer;
102a105
> 		scan(reference.getDeclaringType());
104,106c107
< 			if (!addFieldImport(reference)) {
< 				scan(reference.getDeclaringType());
< 			}
---
> 			addFieldImport(reference);
139a141
> 			CtTypeReference typeReference;
141c143
< 				addClassImport(reference);
---
> 				typeReference = reference;
143c145,149
< 				addClassImport(reference.getAccessType());
---
> 				typeReference = reference.getAccessType();
> 			}
> 
> 			if (!this.isTypeInCollision(typeReference, false)) {
> 				this.addClassImport(typeReference);
280,287c286
< 		if (ref.getPackage().getSimpleName().equals("java.lang")) {
< 			if (classNamePresentInJavaLang(ref)) {
< 				// Don't import class with names clashing with some classes present in java.lang,
< 				// because it leads to undecidability and compilation errors. I. e. always leave
< 				// com.mycompany.String fully-qualified.
< 				return false;
< 			}
< 		}
---
> 
563d561
< 	 * In FQN mode, it only tests the first package name: if a collision occurs with this first one, it should be imported.
579a578,583
> 			// in that case we are trying to import a type because of a literal we are scanning
> 			// i.e. a string, an int, etc.
> 			if (parent instanceof CtLiteral) {
> 				return false;
> 			}
> 
591,592c595,601
< 				if ((parent instanceof CtFieldReference) || (parent instanceof CtExecutableReference)) {
< 					CtReference parentType = (CtReference) parent;
---
> 				if ((parent instanceof CtFieldReference) || (parent instanceof CtExecutableReference) || (parent instanceof CtInvocation)) {
> 					CtReference parentType;
> 					if (parent instanceof CtInvocation) {
> 						parentType = ((CtInvocation) parent).getExecutable();
> 					} else {
> 						parentType = (CtReference) parent;
> 					}
603c612
< 					} else {
---
> 					} else if (parent instanceof CtExecutableReference) {
604a614,615
> 					} else {
> 						typeReference = ((CtInvocation) parent).getExecutable().getDeclaringType();
608c619
< 						qualifiedNameTokens.add(typeReference.getSimpleName());
---
> 						qualifiedNameTokens.addFirst(typeReference.getSimpleName());
611,621c622,626
< 							CtPackage ctPackage = typeReference.getPackage().getDeclaration();
< 
< 							while (ctPackage != null) {
< 								qualifiedNameTokens.add(ctPackage.getSimpleName());
< 
< 								CtElement packParent = ctPackage.getParent();
< 								if (packParent.getParent() != null && !((CtPackage) packParent).getSimpleName().equals(CtPackage.TOP_LEVEL_PACKAGE_NAME)) {
< 									ctPackage = (CtPackage) packParent;
< 								} else {
< 									ctPackage = null;
< 								}
---
> 							StringTokenizer token = new StringTokenizer(typeReference.getPackage().getSimpleName(), CtPackage.PACKAGE_SEPARATOR);
> 							int index = 0;
> 							while (token.hasMoreElements()) {
> 								qualifiedNameTokens.add(index, token.nextToken());
> 								index++;
628,629c633,634
< 						if (fieldAndMethodsNames.contains(qualifiedNameTokens.getLast()) || localVariablesOfBlock.contains(qualifiedNameTokens.getLast())) {
< 							qualifiedNameTokens.removeLast();
---
> 						if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {
> 							qualifiedNameTokens.removeFirst();
632c637,656
< 								return true;
---
> 								// in case we are testing a type: we should not import it if its entire name is in collision
> 								// for example: spoon.Launcher if a field spoon and another one Launcher exists
> 								if (ref instanceof CtTypeReference) {
> 									if (qualifiedNameTokens.isEmpty()) {
> 										return true;
> 									}
> 									// but if the other package names are not a variable name, it's ok to import
> 									for (int i =  0; i < qualifiedNameTokens.size(); i++) {
> 										String testedToken = qualifiedNameTokens.get(i);
> 										if (!fieldAndMethodsNames.contains(testedToken) && !localVariablesOfBlock.contains(testedToken)) {
> 											return true;
> 										}
> 									}
> 									return false;
> 
> 								// However if it is a static method/field, we always accept to import them in this case
> 								// It is the last possibility for managing import for us
> 								} else {
> 									return true;
> 								}
635c659
< 								for (int i = qualifiedNameTokens.size() - 1; i > 0; i--) {
---
> 								for (int i =  0; i < qualifiedNameTokens.size(); i++) {
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/MinimalImportScanner.java after/src/main/java/spoon/reflect/visitor/MinimalImportScanner.java
32c32,33
< 	 * @param ref
---
> 	 * @param ref: the type we are testing, it can be a CtTypeReference, a CtFieldReference or a CtExecutableReference
> 	 *
56a58,63
> 		if (ref.getDeclaringType() != null) {
> 			if (isImportedInClassImports(ref.getDeclaringType())) {
> 				return false;
> 			}
> 		}
> 
72a80,84
> 		if (ref.getDeclaringType() != null) {
> 			if (isImportedInClassImports(ref.getDeclaringType())) {
> 				return false;
> 			}
> 		}
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java after/src/main/java/spoon/reflect/visitor/printer/ElementPrinterHelper.java
286c286
< 				if (!importTypeStr.equals("")) {
---
> 				if (!importTypeStr.equals("") && !importTypeStr.startsWith("java.lang")) {
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/imports/ImportScannerTest.java after/src/test/java/spoon/test/imports/ImportScannerTest.java
57c57,58
< 		assertEquals(2, imports.size());
---
> 		// java.lang are also computed
> 		assertEquals(4, imports.size());
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/imports/ImportTest.java after/src/test/java/spoon/test/imports/ImportTest.java
252c252,253
< 		assertEquals("Spoon ignores the arguments of CtInvocations", 1, imports2.size());
---
> 		// java.lang imports are also computed
> 		assertEquals("Spoon ignores the arguments of CtInvocations", 3, imports2.size());
342c343,344
< 		assertEquals(2, imports.size());
---
> 		// java.lang.Object is considered as imported but it will never be output
> 		assertEquals(3, imports.size());
344c346
< 				Arrays.asList("spoon.test.imports.testclasses.internal3.Foo", "java.io.File"));
---
> 				Arrays.asList("spoon.test.imports.testclasses.internal3.Foo", "java.io.File", "java.lang.Object"));
916a919,930
> 	}
> 
> 	@Test
> 	public void testJavaLangIsConsideredAsImported() {
> 		final Launcher launcher = new Launcher();
> 		launcher.getEnvironment().setAutoImports(false);
> 		String outputDir = "./target/spooned-javalang";
> 		launcher.addInputResource("./src/test/java/spoon/test/imports/testclasses2/JavaLangConflict.java");
> 		launcher.setSourceOutputDirectory(outputDir);
> 		launcher.run();
> 
> 		canBeBuilt(outputDir, 7);
Only in after/src/test/java/spoon/test/imports/testclasses2: JavaLangConflict.java
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/variable/AccessFullyQualifiedFieldTest.java after/src/test/java/spoon/test/variable/AccessFullyQualifiedFieldTest.java
57,58c57,58
< 		assertTrue("The java file should contain import for Launcher", result.contains("import static spoon.Launcher.SPOONED_CLASSES;"));
< 		assertTrue("The xx variable is attributed with Launcher.SPOONED_CLASSES", result.contains("xx = SPOONED_CLASSES"));
---
> 		assertTrue("The java file should contain import for Launcher", result.contains("import spoon.Launcher;"));
> 		assertTrue("The xx variable is attributed with Launcher.SPOONED_CLASSES", result.contains("xx = Launcher.SPOONED_CLASSES"));
69,70c69,70
< 		assertTrue("The java file should contain import for Launcher", result.contains("import static spoon.Launcher.SPOONED_CLASSES;"));
< 		assertTrue("The x variable should be attributed with SPOONED_CLASSES", result.contains("x = SPOONED_CLASSES"));
---
> 		assertTrue("The java file should contain import for Launcher", result.contains("import spoon.Launcher;"));
> 		assertTrue("The x variable should be attributed with SPOONED_CLASSES", result.contains("x = Launcher.SPOONED_CLASSES"));
94c94,95
< 		assertTrue("The xx variable should be attributed with SPOONED_CLASSES", result.contains("xx = SPOONED_CLASSES"));
---
> 		assertTrue("The java file should contain import for Launcher", result.contains("import spoon.Launcher;"));
> 		assertTrue("The xx variable should be attributed with SPOONED_CLASSES", result.contains("xx = Launcher.SPOONED_CLASSES"));
104c105,106
< 		assertTrue("The xx variable should be attributed with SPOONED_CLASSES", result.contains("xx = SPOONED_CLASSES"));
---
> 		assertTrue("The java file should contain import for Launcher", result.contains("import spoon.Launcher;"));
> 		assertTrue("The xx variable should be attributed with SPOONED_CLASSES", result.contains("xx = Launcher.SPOONED_CLASSES"));
