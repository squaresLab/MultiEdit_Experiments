Only in after/: bears.json
Only in after/: classpath.info
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/filter/LocalVariableReferenceFunction.java after/src/main/java/spoon/reflect/visitor/filter/LocalVariableReferenceFunction.java
19a20,21
> import spoon.reflect.declaration.CtElement;
> import spoon.reflect.declaration.CtType;
20a23
> import spoon.reflect.visitor.Filter;
43c46,51
< 	public void apply(CtLocalVariable<?> localVariable, CtConsumer<Object> outputConsumer) {
---
> 	public void apply(final CtLocalVariable<?> localVariable, CtConsumer<Object> outputConsumer) {
> 		final String simpleName = localVariable.getSimpleName();
> 		class Context {
> 			boolean hasLocalType = false;
> 		}
> 		final Context context = new Context();
46c54,74
< 			.select(new DirectReferenceFilter<CtLocalVariableReference<?>>(localVariable.getReference()))
---
> 			.select(new Filter<CtElement>() {
> 				@Override
> 				public boolean matches(CtElement element) {
> 					if (element instanceof CtType) {
> 						context.hasLocalType = true;
> 					} else if (element instanceof CtLocalVariableReference<?>) {
> 						CtLocalVariableReference<?> localVarRef = (CtLocalVariableReference<?>) element;
> 						if (simpleName.equals(localVarRef.getSimpleName())) {
> 							//we have found a variable reference in visibility scope of localVariable
> 							if (context.hasLocalType) {
> 								//there exists a local type in visibility scope of this variable declaration
> 								//the variable declarations in scope of this local class may shadow input localVariable
> 								//so finally check that there is no other localVariable, which shadows the input localVariable
> 								return localVariable == localVarRef.getDeclaration();
> 							}
> 							return true;
> 						}
> 					}
> 					return false;
> 				}
> 			})
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/reflect/visitor/filter/LocalVariableScopeFunction.java after/src/main/java/spoon/reflect/visitor/filter/LocalVariableScopeFunction.java
19,21d18
< import java.util.List;
< 
< import spoon.SpoonException;
23,24d19
< import spoon.reflect.code.CtStatement;
< import spoon.reflect.code.CtStatementList;
27d21
< import spoon.reflect.visitor.chain.CtQuery;
53,69c47
< 		CtStatementList statements = localVariable.getParent(CtStatementList.class);
< 		if (statements == null) {
< 			//cannot search for variable references of variable which has no parent statement list/block
< 			return;
< 		}
< 		//create query which will be evaluated on each statement after local variable declaration
< 		CtQuery query = localVariable.getFactory().createQuery().filterChildren(null);
< 		List<CtStatement> stats = statements.getStatements();
< 		//search for variable declaration in statements of current block
< 		int idxOfVar = stats.indexOf(localVariable);
< 		if (idxOfVar < 0) {
< 			throw new SpoonException("Cannot found index of local variable declaration " + localVariable + " in statement list " + statements);
< 		}
< 		//scan only all elements AFTER this variable declaration
< 		for (int i = idxOfVar + 1; i < stats.size(); i++) {
< 			query.setInput(stats.get(i)).forEach(outputConsumer);
< 		}
---
> 		localVariable.map(new SiblingsFunction().mode(SiblingsFunction.Mode.NEXT).includingSelf(true)).filterChildren(null).forEach(outputConsumer);
Only in after/src/main/java/spoon/reflect/visitor/filter: PotentialVariableDeclarationFunction.java
Only in after/src/main/java/spoon/reflect/visitor/filter: SiblingsFunction.java
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/main/java/spoon/support/reflect/reference/CtLocalVariableReferenceImpl.java after/src/main/java/spoon/support/reflect/reference/CtLocalVariableReferenceImpl.java
20,21c20
< import spoon.reflect.declaration.CtElement;
< import spoon.reflect.declaration.CtPackage;
---
> import spoon.reflect.declaration.CtVariable;
26,28c25,26
< import spoon.reflect.visitor.filter.AbstractFilter;
< 
< import java.util.List;
---
> import spoon.reflect.visitor.Filter;
> import spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction;
52a51
> 	@SuppressWarnings("unchecked")
60d58
< 		final SimpleNameFilter filter = new SimpleNameFilter();
62,64c60,68
< 		// successively iterate through all parents of this reference and
< 		// return first result (which must be the closest declaration
< 		// respecting visible scope)
---
> 		final String simpleName = getSimpleName();
> 
> 		//handle the CtLocalVariableReference which were created by CtLocalVariable#getReference() and which are not yet part of model, so we cannot found them using standard rules
> 		if (parent instanceof CtLocalVariable) {
> 			CtLocalVariable<T> var = (CtLocalVariable<T>) parent;
> 			if (simpleName.equals(var.getSimpleName())) {
> 				return var;
> 			}
> 		}
66,79c70,76
< 			CtElement parent = getParent();
< 			// stop at `package` level to avoid lookups to foreign Java files
< 			while (parent != null && !(parent instanceof CtPackage)) {
< 				final List<CtLocalVariable<T>> localVariables =
< 						parent.getElements(filter);
< 				// since `parent` may be a class declaring multiple local
< 				// variables with same name in different methods, we have to
< 				// check if any of the findings is visible in current scope by
< 				// validating that the parent of a finding is parent of this
< 				// reference as well
< 				for (final CtLocalVariable<T> lv : localVariables) {
< 					if (getParent().equals(lv) || hasParent(lv.getParent())) {
< 						return lv;
< 					}
---
> 			// successively iterate through all parents of this reference and
> 			// return first result (which must be the closest declaration
> 			// respecting visible scope)
> 			CtVariable<?> var = map(new PotentialVariableDeclarationFunction()).select(new Filter<CtVariable<?>>() {
> 				@Override
> 				public boolean matches(CtVariable<?> var) {
> 					return simpleName.equals(var.getSimpleName());
81c78,80
< 				parent = parent.getParent();
---
> 			}).first();
> 			if (var instanceof CtLocalVariable) {
> 				return (CtLocalVariable<T>) var;
83c82,87
< 		} catch (final ParentNotInitializedException e) {
---
> 			if (var != null) {
> 				//we have found another variable declaration with same simple name, which hides declaration of this local variable reference
> 				//handle it as not found
> 				return null;
> 			}
> 		} catch (ParentNotInitializedException e) {
92,109d95
< 	}
< 
< 	/**
< 	 * A {@link spoon.reflect.visitor.Filter} that filters all
< 	 * {@link CtLocalVariable}s with simple name equals to
< 	 * {@link #getSimpleName()}.
< 	 */
< 	private final class SimpleNameFilter
< 			extends AbstractFilter<CtLocalVariable<T>> {
< 
< 		SimpleNameFilter() {
< 			super();
< 		}
< 
< 		@Override
< 		public boolean matches(final CtLocalVariable<T> element) {
< 			return element.getSimpleName().equals(getSimpleName());
< 		}
Only in after/src/test/java/spoon/test/query_function: VariableReferencesModelTest.java
Only in after/src/test/java/spoon/test/query_function: VariableReferencesTest.java
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/reference/testclasses/Tortillas.java after/src/test/java/spoon/test/reference/testclasses/Tortillas.java
5a6
> 		int number = number=40;
diff -r -x '*.log' -x '*.config' -x '*git*' -x '*.md' -x '*.xml' before/src/test/java/spoon/test/reference/VariableAccessTest.java after/src/test/java/spoon/test/reference/VariableAccessTest.java
18a19
> import spoon.reflect.visitor.filter.LocalVariableReferenceFunction;
178a180,193
> 	}
> 	@Test
> 	public void testReferencesInInitExpression() throws Exception {
> 		/* test getReference on local variable
> 		*  getReference().getDeclaration() must be circular
> 		*/
> 
> 		final CtType<Tortillas> aTortillas = buildClass(Tortillas.class);
> 		final CtMethod<Object> make = aTortillas.getMethod("make", aTortillas.getFactory().Type().stringType());
> 		
> 		final CtLocalVariable localVarNumber = make.getBody().getStatement(1);
> 		List<CtLocalVariableReference<?>> refs = localVarNumber.map(new LocalVariableReferenceFunction()).list();
> 		assertEquals(1, refs.size());
> 		assertSame(localVarNumber, refs.get(0).getParent(CtLocalVariable.class));
